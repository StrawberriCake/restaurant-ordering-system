name: Build and push frontend/backend image to ECR and deploy to EKS
run-name: ${{ github.actor }} is running ECR-EKS build-push-deploy on GitHub Actions ðŸš€
on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'The branch to build'
        required: true
      environment:
        description: 'The environment to deploy to'
        required: false
  push:
    paths:
      - 'backend/**'
      - 'frontend/**'

env:
  AWS_REGION: us-east-1
  ECR_ENDPOINT: public.ecr.aws/u2q1a2y8
  BACKEND_IMAGE_NAME: ce5-group2-backend
  FRONTEND_IMAGE_NAME: ce5_group2_frontend
  EKS_CLUSTER_NAME: ce5-group2-eks-cluster

jobs:
  check_for_image_to_build:
    permissions:
      id-token: write
      contents: read
      pull-requests: read
    outputs:
      IMAGES_TO_BUILD: ${{ steps.set_images.outputs.IMAGES_TO_BUILD }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get changed files manually
        run: |
          files_list="$(git diff --name-only ${{ github.event.before }} HEAD | xargs)"
          echo '# Files with git command' >> "${GITHUB_STEP_SUMMARY}"
          echo '' >> "${GITHUB_STEP_SUMMARY}"
          echo '```' >> "${GITHUB_STEP_SUMMARY}"

          for file in ${files_list}; do
            echo "$file was changed" >> "${GITHUB_STEP_SUMMARY}"
          done

          echo '```' >> "${GITHUB_STEP_SUMMARY}"

          # save files into variable
          printf 'CHANGED_FILES=%s\n' "${files_list}" >> "${GITHUB_ENV}"

      - name: Get docker image names
        shell: python
        env:
          PROJECT_IMAGE_MAP: '{"backend": "${{ env.BACKEND_IMAGE_NAME }}", "frontend": "${{ env.FRONTEND_IMAGE_NAME }}"}'
        run: |
          from os import environ
          import json
          
          # split files string into list. Divide by spaces
          files = environ.get("CHANGED_FILES").split(' ')
          print(files)
          proj_image_map = json.loads(environ.get("PROJECT_IMAGE_MAP"))
          print(proj_image_map)

          images = []

          # check if backend, frontend, etc is a part of changed file path
          for file in files:
            for k, v in proj_image_map.items():
              if k in file:
                if v not in images:
                  images.append(v)

          # save retreived images as json array
          with open(environ.get("GITHUB_ENV"), 'a') as f:
            f.write('IMAGES_TO_BUILD=' + json.dumps(images) + '\n')

      - name: Set image names as output
        id: set_images
        run: |
          echo "TEST_IMAGES=[\"ce5-group2-backend\", \"ce5_group2_frontend\"]" > images.json
          echo "$TEST_IMAGES"
          frontend_image=$(jq -r '.[] | select(contains("frontend"))' images.json)
          echo "Frontend image: $frontend_image"

          echo "IMAGES_TO_BUILD=${IMAGES_TO_BUILD}" >> $GITHUB_OUTPUT

  build_and_push_image:
    runs-on: ubuntu-latest
    needs: [check_for_image_to_build]
    env:
      IMAGE_TAG: latest
      IMAGES_TO_BUILD:  ${{ needs.check_for_image_to_build.outputs.IMAGES_TO_BUILD }}
    if: needs.check_for_image_to_build.outputs.IMAGES_TO_BUILD != '[]'
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to AWS ECR
        id: login-ecr
        run: aws ecr-public get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_ENDPOINT }}

      - name: Build and push frontend image to ECR
        run: |
          images=${{ env.IMAGES_TO_BUILD }}
          images=${images//[\[\]\" ]/}
          IFS=',' read -r -a image_array <<< "$images"

          for image in "${image_array[@]}"; do
            image=$(echo $image | xargs)
            if [ "$image" == "${{ env.FRONTEND_IMAGE_NAME }}" ]; then
              echo "Building frontend image.."
              docker build -t ${{ env.FRONTEND_IMAGE_NAME }} ./frontend
              docker tag ${{ env.FRONTEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }} ${{ env.ECR_ENDPOINT }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
              echo "Pushing frontend image to ECR..."
              docker push ${{ env.ECR_ENDPOINT }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
            else
              echo "No frontend image to build..."
            fi
          done

      - name: Build and push backend image to ECR
        run: |
          images=${{ env.IMAGES_TO_BUILD }}
          images=${images//[\[\]\" ]/}
          IFS=',' read -r -a image_array <<< "$images"

          for image in "${image_array[@]}"; do
            image=$(echo $image | xargs)
            if [ "$image" == "${{ env.BACKEND_IMAGE_NAME }}" ]; then
              echo "Building backend image..."
              docker build -t ${{ env.BACKEND_IMAGE_NAME }} ./backend
              docker tag ${{ env.BACKEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }} ${{ env.ECR_ENDPOINT }}/${{ env.BACKEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
              echo "Pushing backend image to ECR..."
              docker push ${{ env.ECR_ENDPOINT }}/${{ env.BACKEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
            else
              echo "No backend image to build..."
            fi
          done

  deploy_to_eks:
    runs-on: ubuntu-latest
    needs: [check_for_image_to_build, build_and_push_image]
    if: needs.build-and-push-image.outputs.IMAGES_TO_BUILD != '[]'
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Update kube config
        run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Deploy to EKS
        run: |
          kubectl apply -f deployment/kubernetes/frontend.yaml
          kubectl apply -f deployment/kubernetes/backend.yaml